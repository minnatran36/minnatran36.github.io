<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>S&P 500 — Daily / Weekly / Monthly Returns</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
  Chart.defaults.responsive = true;
  Chart.defaults.maintainAspectRatio = false;
  </script>


  <style>
    :root { --bg:#0b0c10; --fg:#e5e7eb; --muted:#9ca3af; --card:#111827; --accent:#60a5fa; --accent2:#f87171; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; background:var(--bg); color:var(--fg); }
    header { display:flex; gap:12px; align-items:center; padding:16px; background:#111213; border-bottom:1px solid #1f2937; }
    select, button { background:#0f172a; color:var(--fg); border:1px solid #1f2937; border-radius:10px; padding:8px 10px; }
    main { display:grid; grid-template-columns: 1fr 300px; gap:16px; padding:16px; }

     .card { background:var(--card); border:1px solid #1f2937; border-radius:14px; padding:12px; }
  /* NEW: keep the chart from stretching */
    .card canvas {
        width: 100% !important;   /* Chart.js reads parent width */
        height: 360px !important; /* matches the canvas height attribute */
        display: block;           /* remove inline baseline gap */
    }

    .row { display:flex; gap:12px; align-items:center; }
    .k { color:var(--muted); width:110px; }
    .v { font-variant-numeric: tabular-nums; }
    .legend { display:flex; gap:8px; align-items:center; font-size:12px; color:var(--muted); margin-top:8px; }
    .dot { width:10px; height:10px; border-radius:50%; display:inline-block; background:var(--accent); }
    .sq { width:10px; height:10px; display:inline-block; background:var(--accent2); }
    footer { color:var(--muted); font-size:12px; padding:0 16px 16px; }
    a { color:#93c5fd; text-decoration:none; }
    a:hover { text-decoration:underline; }
  </style>
</head>
<body>
  <header>
    <div style="font-weight:600;">S&P 500 Returns Viewer</div>
    <select id="ticker"></select>
    <select id="year">
      <option>2019</option><option>2020</option><option>2021</option>
      <option>2022</option><option>2023</option><option selected>2024</option>
    </select>
    <button id="reload">Load</button>
    <div style="margin-left:auto; color:#a1a1aa; font-size:12px;">
      Adjusted Close · Daily line + Weekly (●) + Monthly (■)
    </div>
  </header>

  <main>
    <div class="card">
      <canvas id="chart" height="360"></canvas>
      <div class="legend">
        <span class="dot"></span> Weekly endpoint (●)
        <span class="sq"></span> Monthly endpoint (■)
      </div>
    </div>

    <div class="card" id="metrics">
      <div style="font-weight:600; margin-bottom:8px;">Hover Metrics</div>
      <div class="row"><div class="k">Date</div><div class="v" id="m-date">—</div></div>
      <div class="row"><div class="k">Adj Close</div><div class="v" id="m-price">—</div></div>
      <div class="row"><div class="k">Day return</div><div class="v" id="m-day">—</div></div>
      <div class="row"><div class="k">Week return</div><div class="v" id="m-week">—</div></div>
      <div class="row"><div class="k">Month return</div><div class="v" id="m-month">—</div></div>
      <hr style="border:0;border-top:1px solid #1f2937; margin:10px 0;">
      <div style="font-size:12px; color:var(--muted);">
        Tip: hover near markers to see weekly/monthly returns. Not every day is an endpoint.
      </div>
    </div>

    <div class="card" id="news">
        <div style="display:flex;align-items:center;justify-content:space-between;">
            <div style="font-weight:600;">Headlines</div>
            <div id="news-range" class="badge">—</div>
        </div>
        <div id="news-list" style="margin-top:8px; display:grid; gap:8px; font-size:14px; line-height:1.3;"></div>
        <div style="font-size:12px; color:#9ca3af; margin-top:8px;">
    Tip: click a <b>weekly</b> (●) or <b>monthly</b> (■) marker to load headlines for that week/month.
    Click anywhere else to load ±3 days around that date.
    </div>
</div>

  </main>

  <footer>
    Returns are mechanical; markers denote last trading day of week/month.
    <a href="#" id="debugLink">Debug JSON</a>
  </footer>

  <script>
    // Change this if your server runs elsewhere:
    const API_BASE = "/api";

    const elTicker = document.getElementById("ticker");
    const elYear   = document.getElementById("year");
    const elReload = document.getElementById("reload");
    const elMDate  = document.getElementById("m-date");
    const elMPrice = document.getElementById("m-price");
    const elMDay   = document.getElementById("m-day");
    const elMWeek  = document.getElementById("m-week");
    const elMMonth = document.getElementById("m-month");
    const debugLink= document.getElementById("debugLink");
    const elNewsList  = document.getElementById("news-list");
    const elNewsRange = document.getElementById("news-range");


    let blob = null;   // ReturnsBlob from /api/returns/:ticker?year=YYYY
    let chart = null;

    function pct(x) { return (x == null ? "—" : (x*100).toFixed(2) + "%"); }
    function fmt(n) { return n == null ? "—" : Number(n).toFixed(2); }

    async function fetchSP500() {
      const r = await fetch(`${API_BASE}/sp500`);
      if (!r.ok) throw new Error("Failed to load S&P 500 list");
      const j = await r.json();
      return j.tickers;
    }
    async function fetchReturns(ticker, year) {
      const r = await fetch(`${API_BASE}/returns/${ticker}?year=${year}`);
      if (!r.ok) throw new Error((await r.json()).error || "returns error");
      return r.json();
    }

    function buildChartData(blob) {
      const labels = blob.daily.map(d => d.date);
      const price  = blob.daily.map(d => d.adjClose);

      const weeklySet  = new Set(blob.weeklyEndpoints);
      const monthlySet = new Set(blob.monthlyEndpoints);

      const weeklyPoints = blob.daily
        .filter(d => weeklySet.has(d.date))
        .map(d => ({ x: d.date, y: d.adjClose }));

      const monthlyPoints = blob.daily
        .filter(d => monthlySet.has(d.date))
        .map(d => ({ x: d.date, y: d.adjClose }));

      return { labels, price, weeklyPoints, monthlyPoints };
    }

    function renderChart() {
      const ctx = document.getElementById('chart').getContext('2d');
      const { labels, price, weeklyPoints, monthlyPoints } = buildChartData(blob);

      if (chart) chart.destroy();
      chart = new Chart(ctx, {
        type: 'line',
        data: {
          labels,
          datasets: [
            {
              label: 'Adj Close',
              data: price,
              borderColor: '#93c5fd',
              borderWidth: 1.5,
              pointRadius: 0,
              tension: 0.2
            },
            {
              type: 'scatter',
              label: 'Weekly endpoints',
              data: weeklyPoints,
              pointBackgroundColor: '#60a5fa',
              pointBorderColor: '#60a5fa',
              pointRadius: 4,
              showLine: false
            },
            {
              type: 'scatter',
              label: 'Monthly endpoints',
              data: monthlyPoints,
              pointBackgroundColor: '#f87171',
              pointBorderColor: '#f87171',
              pointStyle: 'rect',
              pointRadius: 4,
              showLine: false
            }
          ]
        },
        options: {
          animation: false,
          maintainAspectRatio: false,
          scales: {
            x: { ticks: { display:false }, grid: { display:false } },
            y: { ticks: { color:'#9ca3af' }, grid: { color: '#1f2937' } }
          },
          interaction: { mode: 'nearest', intersect: false },
          plugins: {
            legend: { display:false },
            tooltip: {
              enabled: true,
              callbacks: {
                title: items => items[0]?.label || '',
                label: ctx => {
                  const date = ctx.label || ctx.raw?.x;
                  const row = blob.daily.find(r => r.date === date);
                  if (!row) return '';
                  const isWeekly  = blob.weeklyEndpoints.includes(date);
                  const isMonthly = blob.monthlyEndpoints.includes(date);
                  const day   = row.dailyReturn;
                  const week  = isWeekly  ? blob.weeklyReturns[date]  : null;
                  const month = isMonthly ? blob.monthlyReturns[date] : null;

                  // Update side metrics panel
                  elMDate.textContent  = date;
                  elMPrice.textContent = fmt(row.adjClose);
                  elMDay.textContent   = pct(day);
                  elMWeek.textContent  = pct(week);
                  elMMonth.textContent = pct(month);

                  return [
                    `Adj Close: ${fmt(row.adjClose)}`,
                    `Day: ${pct(day)}`,
                    `Week: ${pct(week)}`,
                    `Month: ${pct(month)}`
                  ];
                }
              }
            }
          }
        }
        
      });
      
      chart.options.onClick = async (_evt, activeEls) => {
        if (!blob) return;
        // Determine clicked date
        let dateISO = null;
        if (activeEls && activeEls.length > 0) {
            const el = activeEls[0];
            // scatter points have raw.x, line points use label
            const raw = el.element?.$context?.raw;
            dateISO = (raw && raw.x) ? raw.x : blob.daily[el.index]?.date;
        }
        if (!dateISO) return;

        // Decide range: week if weekly endpoint, month if monthly endpoint, else ±3 days
        let range;
        const isWeekly  = blob.weeklyEndpoints.includes(dateISO);
        const isMonthly = blob.monthlyEndpoints.includes(dateISO);
        if (isMonthly)      range = monthRange(dateISO);
        else if (isWeekly)  range = weekRange(dateISO);
        else                range = { start: addDays(dateISO, -3), end: addDays(dateISO, 3) };

        try {
            const payload = await fetchHeadlines(blob.ticker, range.start, range.end);
            renderHeadlines(elNewsList, elNewsRange, payload);
        } catch (e) {
            elNewsRange.textContent = "—";
            elNewsList.innerHTML = `<div style="color:#fca5a5;">${e.message || e}</div>`;
        }
        };


    }

    async function boot() {
      try {
        const tickers = await fetchSP500();
        elTicker.innerHTML = `<option value="" disabled selected>Pick S&P 500</option>` +
          tickers.map(t => `<option value="${t}">${t}</option>`).join('');
      } catch (e) {
        elTicker.innerHTML = `<option value="" disabled selected>(failed to load S&P list)</option>`;
        console.error(e);
      }

      document.getElementById("reload").addEventListener('click', async () => {
        const t = elTicker.value;
        const y = Number(elYear.value);
        if (!t) { alert("Pick a ticker"); return; }
        try {
          blob = await fetchReturns(t, y);
          renderChart();
          debugLink.onclick = (e) => { e.preventDefault(); const w = window.open(); w.document.write(`<pre>${JSON.stringify(blob, null, 2)}</pre>`); };
        } catch (e) {
          alert(e.message || e);
        }
      });
    }

    boot();
  
  
    async function fetchHeadlines(ticker, start, end) {
        const r = await fetch(`${API_BASE}/headlines/${ticker}?start=${start}&end=${end}`);
        if (!r.ok) throw new Error((await r.json()).error || "headlines error");
        return r.json(); // { ticker, start, end, headlines: [...] }
    }

    function iso(d) { return new Date(d).toISOString().slice(0,10); }
    function addDays(d, n) { const x = new Date(d + "T00:00:00Z"); x.setUTCDate(x.getUTCDate()+n); return iso(x); }

  // Week boundaries: Monday..Sunday (UTC)
    function weekRange(dateISO) {
        const d = new Date(dateISO + "T00:00:00Z");
        const dow = (d.getUTCDay() + 6) % 7; // 0=Mon..6=Sun
        const start = addDays(dateISO, -dow);
        const end   = addDays(start, 6);
        return { start, end };
  }

    function monthRange(dateISO) {
        const y = Number(dateISO.slice(0,4)), m = Number(dateISO.slice(5,7)) - 1;
        const start = iso(new Date(Date.UTC(y, m, 1)));
        const end   = iso(new Date(Date.UTC(y, m+1, 0))); // last day of month
        return { start, end };
    }

    function renderHeadlines(box, rangeEl, payload) {
        rangeEl.textContent = `${payload.start} → ${payload.end}`;
        const list = payload.headlines;
        box.innerHTML = list.length
        ? list.slice(0, 20).map(h => `
            <div>
                <a href="${h.url || '#'}" target="_blank" rel="noopener">${h.title}</a>
                <div style="color:#9ca3af; font-size:12px;">${h.source || ''} · ${h.date}${h.syndicatedCount?` · ${h.syndicatedCount+1} pubs`:''}</div>
            </div>
            `).join('')
        : `<div style="color:#9ca3af;">No headlines in this range.</div>`;
    }
</script>

</body>
</html>
